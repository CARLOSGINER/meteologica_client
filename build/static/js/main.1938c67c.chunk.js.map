{"version":3,"sources":["components/Chart.js","components/Widget.js","components/Header.js","components/Footer.js","App.js","index.js"],"names":["Plot","createPlotlyComponent","Plotly","globalColor","Chart","getLastTemp","getLastPower","useState","temperatures","setTemperatures","power","setPower","onLight","setOnLight","makeAxis","rawData","map","each","time","value","tempTimeArray","plotReadyTemps","plotReadyPowers","lastTemperature","length","lastPower","useEffect","socket","socketIOClient","on","console","log","connected","resp","updatedTemperatures","updatedPowers","disconnect","toFixed","tempXaxisOptions","range","title","titlefont","color","tickfont","tickmode","dtick","tempYaxisOptions","powerXaxisOptions","powerYaxisOptions","className","data","type","mode","x","y","layout","font","xaxis","yaxis","paper_bgcolor","plot_bgcolor","Widget","lastTemp","Header","src","alt","Footer","App","setLastTemp","setLastPower","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1938c67c.chunk.js","sourcesContent":["import { useState, useEffect } from \"react\";\r\nimport socketIOClient from \"socket.io-client\";\r\nimport Plotly from 'plotly.js-basic-dist';\r\nimport createPlotlyComponent from 'react-plotly.js/factory';\r\n\r\nconst Plot = createPlotlyComponent(Plotly);\r\n\r\n// <> para recibir del servidor en vivo de heroku, descomentar linea siguiente:\r\nconst ENDPOINT = \"https://meteologica-app-server.herokuapp.com\"\r\n\r\n// <> para probar localmente, descomentar linea siguiente:\r\n//tambien es necesario copiar la misma dirección en el package.json, como un key despues de scripts:\r\n//\"proxy\": \"http://127.0.0.1:4001\"\r\n// const ENDPOINT = \"http://127.0.0.1:4001\";\r\n\r\nconst globalColor = '#111d2b'\r\n\r\n//Este componente recibe como props, métodos para enviar al padre App, las ultimas temperatura y potencia del array\r\n\r\nexport default function Chart({getLastTemp,getLastPower}) {\r\n    \r\n    const [temperatures, setTemperatures] = useState([]);\r\n    const [power, setPower] = useState([]);\r\n    const [onLight, setOnLight] = useState(false);  \r\n    \r\n\r\n    //método que recibe un array de temperaturas en Kelvin y devuelve un array de temperaturas en °C\r\n    const tempsInCelsius =(kelvinTemperatures) =>{\r\n        const convertedTemperatures = kelvinTemperatures.map(each=>{\r\n            const celsius = each - 273.15\r\n            return (celsius)\r\n        })\r\n        return convertedTemperatures\r\n    }\r\n\r\n    //método que recibe un array de potencias en MW y devuelve un array de potencias en KW\r\n    const toKW = (MWpowers) =>{\r\n        const KWpowers= MWpowers.map(each=>{\r\n            return each*1000\r\n        })\r\n        return KWpowers\r\n    }\r\n\r\n  \r\n    //método que recibe el un array de datos de tiempo y valores y devuelve dos array separados, uno para tiempo y  otro para los valores correspondientes\r\n    const makeAxis = (rawData) =>{\r\n        const xAxis = rawData.map((each)=>(\r\n            each.time\r\n        ))\r\n        const yAxis = rawData.map((each)=>(\r\n            each.value\r\n        ))\r\n        const plotData = [xAxis,yAxis]\r\n        return plotData;\r\n    }\r\n    \r\n    //Se prepara el array de tiempos, para eje X de grafica, makeAxis devuelve un array de dos array, tiempo y valores.\r\n    let tempTimeArray = makeAxis(temperatures)[0]\r\n\r\n    //Se prepara los dos arrays para temp y pot. respectivamente,  para pasar al componente de  plotly.js y graficar\r\n    let plotReadyTemps = tempsInCelsius(makeAxis(temperatures)[1])\r\n    let plotReadyPowers = toKW(makeAxis(power)[1])\r\n\r\n    //valores para el widget, en el primer renderizado muestra 0.\r\n    let lastTemperature = typeof plotReadyTemps[plotReadyTemps.length-1] === \"undefined\"? 0 : plotReadyTemps[plotReadyTemps.length-1]  ; \r\n    let lastPower = typeof plotReadyPowers[plotReadyPowers.length-1] === \"undefined\"? 0 : plotReadyPowers[plotReadyPowers.length-1]; \r\n    \r\n    //UseEffect: En el primer renderizado se conecta con el ENDPOINT especificado a traves de la libreria de socket.io-client. Luego el socket escucha por \r\n    //el evento \"sendingData\" y la respuesta es un objeto donde vienen un array para temperatura y otro para potencia, actualizados desde el servidor. \r\n    //finalmente en el evento \"disconnect\" cambia el estado de onLight, que hace de luz testigo y aplica estilos en el UI\r\n    // (verde, recibiendo datos. O desconectado, rojo)\r\n    useEffect(() => {\r\n        const socket = socketIOClient(ENDPOINT)\r\n\r\n        socket.on(\"connect\", () => {\r\n            console.log('Socket connected: ',socket.connected); \r\n        });\r\n\r\n        socket.on(\"sendingData\", resp => {\r\n            setTemperatures(resp.updatedTemperatures);\r\n            setPower(resp.updatedPowers);\r\n            setOnLight(true);\r\n        });\r\n\r\n\r\n        socket.on(\"disconnect\", () => {\r\n            setOnLight(false);\r\n        });\r\n\r\n        return ()=>socket.disconnect();\r\n    }, []);\r\n\r\n    //useEffect para llamar los métodos provistos por el padre App para leer la temp y pot. mas recientes. Tambien se redeondea a dos decimales\r\n    //para mejor vizualizacion en el widget. \r\n    useEffect(()=>{\r\n        getLastTemp(lastTemperature.toFixed(2))\r\n        getLastPower(lastPower.toFixed(2))\r\n    },[lastTemperature,lastPower,getLastTemp,getLastPower])\r\n\r\n    //A continuación se definen los objetos que configurarán los ejes x y Y de cada gráfica. (detalles en docs de plotly.js)\r\n    const tempXaxisOptions = {\r\n        range:[(tempTimeArray.length)-120,tempTimeArray.length],\r\n        title:'Time',\r\n        titlefont:{color:'white'},\r\n        tickfont:{color:'white'},\r\n        tickmode:'linear',\r\n        dtick:12,\r\n    }\r\n\r\n    const tempYaxisOptions = {\r\n        //Esta es la forma que encontré para mantener la linea visible. Pues mientras el eje x se va \"deslizando\" se pierde el rango, entonces\r\n        //definiendo el rango como el ultimo dato mas/menos un estimado de lo que varía, siempre quedará visible lo mas nuevo de la grafica.\r\n        range:[lastTemperature-0.2,lastTemperature+0.9],\r\n        title:'Temp (C°)',\r\n        titlefont:{color:'white'},      \r\n        tickfont:{color:'white'}\r\n    }\r\n\r\n    const powerXaxisOptions = {\r\n        //para los ejex X, el numero 120 sale de mostrar 10 minutos de rango visible. Pues cada minuto son 12 intervalor (dtick) de 5 segundos.\r\n        range:[(tempTimeArray.length)-120,tempTimeArray.length],\r\n        title:'Time',\r\n        titlefont:{color:'white'},\r\n        tickfont:{color:'white'},\r\n        tickmode:'linear',\r\n        dtick:12,\r\n    }\r\n\r\n    const powerYaxisOptions = {\r\n        //Estos números son arbitrarios y dependen del tipo de datos. Para los proveidos res un rango que permanece visible las ultimas potencias.\r\n        range:[lastPower-500,lastPower+1000],\r\n        title:'Power (KW)',\r\n        titlefont:{color:'white'},\r\n        tickfont:{color:'white'}\r\n    }\r\n\r\n  return (\r\n\r\n    <>\r\n        <div className={onLight?\"loader active\":\"loader\"}>\r\n            {onLight?<p>Connected! receiving data</p>:<p>Disconnected...</p>}\r\n        </div>\r\n\r\n        <div className=\"charts\">\r\n\r\n            <Plot\r\n                data={[\r\n                    {\r\n                        type:'scatter',\r\n                        mode:'lines',\r\n                        x:tempTimeArray,\r\n                        y:plotReadyTemps\r\n                    }\r\n                ]}  \r\n\r\n                layout={{\r\n                    title:'Temperature',\r\n                    font:{\r\n                        color:'rgb(179, 179, 179)'\r\n                    },\r\n                    xaxis:tempXaxisOptions,\r\n                    yaxis:tempYaxisOptions,\r\n                    paper_bgcolor:globalColor,\r\n                    plot_bgcolor:globalColor,\r\n                }}\r\n            />\r\n            <Plot\r\n                data={[\r\n                    {\r\n                        type:'scatter',\r\n                        mode:'lines',\r\n                        x:tempTimeArray,\r\n                        y:plotReadyPowers\r\n                    }\r\n                ]}\r\n                layout={{\r\n                    title:'Power',\r\n                    font:{\r\n                        color:'rgb(179, 179, 179)'\r\n                    },\r\n                    xaxis:powerXaxisOptions,\r\n                    yaxis:powerYaxisOptions,\r\n                    paper_bgcolor:globalColor,\r\n                    plot_bgcolor:globalColor,\r\n\r\n                }}\r\n            />\r\n        </div>\r\n    </>\r\n  );\r\n}\r\n\r\n","import React from 'react';\r\n\r\n\r\nexport default function Widget({lastTemp,lastPower}) {\r\n    return (\r\n      <div className=\"widget\">\r\n          <div >\r\n              <p className=\"subtitle\">Temperature</p>\r\n              <p className=\"number\">{lastTemp} °C</p>\r\n          </div>\r\n          <div className=\"divider\">\r\n              |\r\n          </div>\r\n          <div>\r\n              <p className=\"subtitle\">Power</p>\r\n              <p className=\"number\" >{lastPower} KW</p>\r\n          </div>\r\n      </div>\r\n    );\r\n}\r\n","import React from 'react'\r\nimport Widget from './Widget';\r\n\r\nexport default function Header({lastTemp,lastPower}) {\r\n    return (\r\n        <nav className=\"header\">\r\n            <img className=\"logo_img\" src={\"/assets/meteologica_logo.jpg\"} alt=\"logo\" />\r\n            <Widget lastTemp={lastTemp} lastPower={lastPower}/>\r\n        </nav>\r\n    )\r\n}\r\n","import React from 'react'\r\n\r\nexport default function Footer() {\r\n    return (\r\n        <footer>\r\n            <p className=\"copyright\">Develope by Carlos Giner © copyright 2021</p>\r\n        </footer>\r\n    )\r\n}\r\n","import './App.css';\r\nimport React,{useState} from'react';\r\nimport Chart from './components/Chart';\r\nimport Header from './components/Header';\r\nimport Footer from './components/Footer';\r\n\r\nfunction App() {\r\n\r\n  //El componente principal maneja dos estados, para guardar las ultimas temperatura y potencia y pasarlas al\r\n  //componente Widget. Para esto uso dos métodos para poder leer dentro de Chart que es donde se reciben y se procesan\r\n  //los datos en bruto.    \r\n\r\n  const [lastTemp, setLastTemp] = useState(false);\r\n  const [lastPower, setLastPower] = useState(false);\r\n\r\n  const getLastTemp =(lastTemperature)=>{\r\n    setLastTemp(lastTemperature)\r\n  }\r\n\r\n  const getLastPower = (lastPower) => {\r\n    setLastPower(lastPower);\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <Header lastTemp={lastTemp} lastPower={lastPower}/> \r\n      <Chart getLastTemp={getLastTemp} getLastPower={getLastPower} />\r\n      <Footer/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}